"""
Task: T030, T031, T032
JWT authentication middleware.

Validates JWT tokens from Better Auth cookies and extracts user information.
Better Auth uses HTTP-only cookies for session tokens (more secure than headers).
"""

from typing import Callable
from collections import defaultdict
import time

from fastapi import HTTPException, Request, Response, status
from jose import JWTError, jwt

from src.config import settings

# Public endpoints that don't require authentication
PUBLIC_PATHS = {"/", "/health", "/docs", "/redoc", "/openapi.json"}

# Rate limiting storage (in production, use Redis or similar)
rate_limit_storage = defaultdict(list)


def check_rate_limit(request: Request, max_requests: int = 100, window_seconds: int = 3600) -> bool:
    """
    Simple rate limiting implementation.
    In production, use Redis or similar for distributed rate limiting.
    """
    # Get client IP
    client_ip = request.client.host

    # Current time
    now = time.time()

    # Clean old requests outside the window
    rate_limit_storage[client_ip] = [
        req_time for req_time in rate_limit_storage[client_ip]
        if now - req_time < window_seconds
    ]

    # Check if limit exceeded
    if len(rate_limit_storage[client_ip]) >= max_requests:
        return False

    # Add current request
    rate_limit_storage[client_ip].append(now)
    return True


async def jwt_auth_middleware(request: Request, call_next: Callable[[Request], Response]) -> Response:
    """
    Validate JWT token from Authorization header and extract user information.

    The JWT is generated by Next.js /api/auth/token endpoint after validating
    the Better Auth session. This keeps frontend and backend auth layers separate.

    Frontend flow:
    1. User authenticates with Better Auth (session in HTTP-only cookie)
    2. Frontend calls /api/auth/token to get JWT
    3. Frontend caches JWT and sends in Authorization header
    4. Backend validates JWT signature and extracts user_id

    Skips authentication for public endpoints (docs, health check).
    Extracts user_id from JWT 'sub' claim and adds to request.state.

    Args:
        request: FastAPI request object
        call_next: Next middleware/handler in chain

    Returns:
        Response from downstream handler

    Raises:
        HTTPException: 401 if token is missing, invalid, or expired
    """
    # Apply rate limiting to protected endpoints
    if request.url.path not in PUBLIC_PATHS and request.method != "OPTIONS":
        if not check_rate_limit(request, max_requests=100, window_seconds=3600):  # 100 requests per hour
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail="Rate limit exceeded. Please try again later.",
            )

    # Task: T032 - Skip auth for documentation and health endpoints
    if request.url.path in PUBLIC_PATHS:
        return await call_next(request)

    # Skip authentication for CORS preflight requests
    if request.method == "OPTIONS":
        return await call_next(request)

    # Extract JWT token from Authorization header ONLY
    # Note: Better Auth session tokens are NOT JWTs - they're opaque tokens
    # The /api/auth/token endpoint exchanges Better Auth sessions for JWTs
    token = None
    auth_header = request.headers.get("Authorization")
    if auth_header and auth_header.startswith("Bearer "):
        token = auth_header.split(" ")[1]

    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Missing authentication token. Please sign in.",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Task: T030 - Decode and validate JWT
    try:
        payload = jwt.decode(
            token,
            settings.better_auth_secret,
            algorithms=["HS256"],
        )

        # Extract user information from JWT claims
        user_id = payload.get("sub")
        if not user_id:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token: missing 'sub' claim",
            )

        # Add user info to request state for downstream handlers
        request.state.user_id = user_id
        request.state.user_email = payload.get("email")

    except JWTError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Invalid or expired token: {str(e)}",
            headers={"WWW-Authenticate": "Bearer"},
        ) from e

    return await call_next(request)
